import{_ as a,p as e,q as p,a1 as r}from"./framework-5866ffd3.js";const i={},n=r(`<h1 id="前端术语" tabindex="-1"><a class="header-anchor" href="#前端术语" aria-hidden="true">#</a> 前端术语</h1><h2 id="回调" tabindex="-1"><a class="header-anchor" href="#回调" aria-hidden="true">#</a> 回调</h2><p>解释: 从接口调用的角度看，把一个A接口的URL像参数传递那样，传给B接口，A接口会在某个时刻被调用执行，这就叫做回调。 例子: X平台接入公司的统一登录平台：当登录态失效时，X平台调用统一登录平台界面接口，当用户输入手机号码和验证码，统一登录平台校验通过后，统一登录平台再调用X平台提供的登录回调接口，这时统一登录平台会把用户相关信息回传给X平台，X平台注入登录态，最后X平台跳转到首页</p><h2 id="透传" tabindex="-1"><a class="header-anchor" href="#透传" aria-hidden="true">#</a> 透传</h2><p>解释: “透传”从字面上看是：透明无感知地传输数据的含义。 例子: 发短信功能（利用第三方服务腾讯云的发短信接口)：当用户输入手机号码点击发送验证码时，先调用我们自己后台的发短信接口，然后我们后台调用腾讯云的发短信接口，把用户从前端传过来的手机号码再继续传给腾讯云接口。数据传递的链路是：前端-&gt;我们后台-&gt;腾讯云。后台没有对数据做任何修改就直接传给腾讯云的这个过程就是透传。</p><h2 id="回传" tabindex="-1"><a class="header-anchor" href="#回传" aria-hidden="true">#</a> 回传</h2><p>解释: 回传”指的是数据输入方把数据传给第三方后，第三方经过一定的规则转换，再返回数据给输入方的过程 例子: 比如一个小程序把用户的订单数据、商品数据上报给一个第三方数据分析工具，数据分析工具对这些数据进行分析，比如用户喜好分析、圈层分析等，最后把这些分析结果数据再返回给小程序后台，就是回传。</p><h2 id="同步和异步" tabindex="-1"><a class="header-anchor" href="#同步和异步" aria-hidden="true">#</a> 同步和异步</h2><p>解释: 后台对前端发来的接口请求按照响应机制可分为同步接口和异步接口。 同步指的是后台必须处理完所有的任务后，前端才能收到返回处理结果。适用于对实时性要求较高的场景。 异步指的是后台优先返回处理结果给前端，然后再自动执行其他任务。适用于实时性要求不高的场景。 例子: 同步:给用户添加权限时，点击新增后，等待后台返回处理结果成功时，用户就实时拥有了被添加的权限。 异步:批量导入表格数据时，数据量比较大，后台处理比较耗时。当点击确定上传后，批量导入的数据还没有真正入库时，后台就优先返回处理结果，提示“请稍后查看数据”。当后台真正处理完所有数据后，将以站内信、短信等反馈形式通知用户。</p><h2 id="带宽" tabindex="-1"><a class="header-anchor" href="#带宽" aria-hidden="true">#</a> 带宽</h2><p>带宽是指每秒最大能发送或者接收的字节数。指的是网速的大小，比如我们在办理宽带套餐时，有20Mb/s 、100Mb/s等等。</p><h2 id="流量" tabindex="-1"><a class="header-anchor" href="#流量" aria-hidden="true">#</a> 流量</h2><p>流量指的是发送数据和接收数据的大小总和。单位有B,KB,MB,GB。比如我们的手机流量套餐有10块钱100MB，20块钱200MB等</p><h2 id="qps" tabindex="-1"><a class="header-anchor" href="#qps" aria-hidden="true">#</a> qps</h2><p>全名是 Queries Per Second，意思是“每秒查询率”，是一台服务器每秒能够响应的查询次数。是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</p><h2 id="域名和dns" tabindex="-1"><a class="header-anchor" href="#域名和dns" aria-hidden="true">#</a> 域名和DNS</h2><p>域名比ip地址更好记忆，假设ip地址是电话号码，域名就是人名，那么DNS就是通讯录，当你想打电话给某个人时，输入人名，DNS就会从通讯录中找出电话号码拨打。</p><h2 id="控件" tabindex="-1"><a class="header-anchor" href="#控件" aria-hidden="true">#</a> 控件</h2><p>众所周知，html是一门标签语言，组成了网页的基本结构。文本框、按钮、下拉框等最小的界面视觉元素就叫做控件。</p><h2 id="组件" tabindex="-1"><a class="header-anchor" href="#组件" aria-hidden="true">#</a> 组件</h2><p>单纯的控件只是展示了简陋的视觉UI和基本行为，在实际开发中需要用到的是经过各种样式装饰和动画还有丰富行为的UI，而且还会被重复利用。所以为了降低代码重复率，提高开发效率，一般开发会把一个或多个控件的结构、样式、行为、联动封装到一个文件中，这样一个组合文件就称为“组件”。</p><h2 id="组件库" tabindex="-1"><a class="header-anchor" href="#组件库" aria-hidden="true">#</a> 组件库</h2><p>多个组件通过一定的方式封装起来，可以提供给多个项目使用的同一套代码组件，就叫组件库。多个项目使用一套组件库，不仅可以让类似项目保持相同的UI主题，还能避免开发重复造轮子，提高开发效率。 现在市面上比较流行的组件库，有蚂蚁金服ant design，饿了么element ui、iView等。现在很多公司在做网站时，使用的是这几种组件库。当然也有部分公司使用自己研发的组件库。</p><h2 id="框架" tabindex="-1"><a class="header-anchor" href="#框架" aria-hidden="true">#</a> 框架</h2><p>框架是为解决一类问题而产生的产品。它面向的用户是开发者。现在市面上比较流行的前端类框架有： web端：js框架 --&gt; react、vue、angular 客户端：react native、flutter 微信小程序端：wepy、mpvue 它们的诞生，大多是为了解决js操作界面元素的性能消耗、代码复用性、可维护性、可读性、健壮性等问题。</p><h2 id="页面适配" tabindex="-1"><a class="header-anchor" href="#页面适配" aria-hidden="true">#</a> 页面适配</h2><p>页面适配一词一般用于移动端。因为现在的手机机型和手机屏幕种类很多，不同的屏幕大小下，一样的布局可能表现会错乱。不同的机型下，可能因为某个样式不兼容而表现异常。 对手机机型或手机屏幕大小或浏览器大小来对页面样式做兼容匹配，叫做页面适配。</p><h2 id="渲染" tabindex="-1"><a class="header-anchor" href="#渲染" aria-hidden="true">#</a> 渲染</h2><p>众所周知，一个网页基本是由html、css、js构成的。当前端请求回来html、css、js等静态文件后，浏览器引擎就开始按照规则解析语言，然后测量、排版、绘制页面，最后展现出我们眼前的网页视觉效果。这个过程就叫做渲染。 有时候你可能会看到网页展示有点慢或者是卡顿，那就是渲染比较慢。</p><h2 id="cdn" tabindex="-1"><a class="header-anchor" href="#cdn" aria-hidden="true">#</a> CDN</h2><p>cdn是一个为了使用户就近获取内容，提高资源访问速度的一种内容分发网络，主要由内容分发技术和内容缓存设备组成。</p><h2 id="sdk" tabindex="-1"><a class="header-anchor" href="#sdk" aria-hidden="true">#</a> SDK</h2><p>SDK全称是“software development kit”，直译就是软件开发工具集。 说的通俗点，SDK其实就是一个面向开发者的，提供一些功能需求的一份代码程序，它一般会暴露一些方法给开发者去调用; 基于它，开发者就可以快速调用一些功能， 比如微信扫码登录sdk，我们把sdk引入我们的代码中时，就可以快速实现扫码登录功能； 神策埋点SDK，我们引入它，就可以快速实现埋点功能； 腾讯广告SDK，我们引入它，就可以查看投放广告后的分析效果； 前端性能监控SDK，我们引入它，就可以查看我们网站的接口返回速度、前端报错信息等，后面可以更好的优化我们的网站性能。 一般来说，一个标准的SDK，会包含若干API，版本管理和使用说明文档。</p><h2 id="接口" tabindex="-1"><a class="header-anchor" href="#接口" aria-hidden="true">#</a> 接口</h2><p>接口是后端设计的一套供给第三方使用的方法。(第三方指前端/后端) 接口通过网络协议来调用，我们最常用的协议是HTTP协议。 在定义一个接口时，会写好接口路径和接口方法名的映射，然后前端通过接口路径来调用方法。 举个例子：一个获取商品列表的接口，接口路径是：/api/getMerchantList，接口方法名是：getMerchantList。</p><p>前端通过请求/api/getMerchantList来调用getMerchantList方法，接着后端会做相关逻辑处理，比如查询数据库，最后返回商品数据。 小结：前端通过请求接口路径来和后端通信。</p><p>但是需要注意的是像这种通过一个http请求接口来通信的方式是单向的，比如只能前端主动发起请求和后端通信，后端不能主动发起请求和前端通信。如果后端想主动和前端通信，可以通过双向通信协议websocket来通信，现在很多聊天工具，都是使用该协议来双向通信的。</p><p>2.接口的组成 一份规范的接口文档，一般是由以下几部分组成：，假设下面是一个获取商品列表的接口。 接口路径: ‘’ 接口描述：获取商品列表 请求类型：get 请求参数：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">{</span>
	<span class="token literal-property property">a</span><span class="token operator">:</span><span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>返回结构:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">{</span>
	<span class="token literal-property property">code</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token comment">// 返回码</span>
	<span class="token literal-property property">data</span><span class="token operator">:</span><span class="token punctuation">{</span>
		<span class="token literal-property property">list</span><span class="token operator">:</span><span class="token punctuation">[</span>
			<span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">&#39;乐事薯片&#39;</span><span class="token punctuation">,</span> <span class="token comment">// 商品名称</span>
			<span class="token literal-property property">price</span><span class="token operator">:</span><span class="token number">13</span> <span class="token comment">// 商品价格</span>
		<span class="token punctuation">]</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token literal-property property">message</span><span class="token operator">:</span><span class="token string">&#39;success&#39;</span> <span class="token comment">//错误信息</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>小结：请求类型指的是http协议的请求方法，最常用的是post/get，一般查询数据类的接口使用get类型，操作数据增删改类的接口使用post类型。 请求参数是后台规定好前端需要传的参数结构，比如前端想要第二页的数据，那传一个 page:2 给后端就可以了。 返回结构是后台规定好返回给前端的数据结构，一般的返回结构包括三个部分：返回码、错误信息、正确数据。</p><p>通过返回码可以让前端知道后端逻辑是否出现错误，比如返回码为0表示成功，返回码为500表示服务器错误。如果返回码不为0 ，前端就可以直接提示错误信息告知用户接口出错了</p><h2 id="app热更新" tabindex="-1"><a class="header-anchor" href="#app热更新" aria-hidden="true">#</a> app热更新</h2><h3 id="_1-app热更新的方式" tabindex="-1"><a class="header-anchor" href="#_1-app热更新的方式" aria-hidden="true">#</a> 1.app热更新的方式</h3><p>app版本更新迭代分为整包更新和热更新。 整包更新是整个app安装包需要重新下载安装，它通过应用市场来更新，整包的体积比较大，下载速度慢。 热更新就是动态下发代码，当用户打开app时，通过网络下载升级包来直接更新，不需要发布新版本到应用市场。升级包的体积比较小，下载速度快。 发布一个app新版本，要上架到应用市场是需要审核的。</p><p>ios应用市场审核很严格而且审核需要一定的时间，android市场也一样，遇到一些节假日会往后延期。 热更新的方式可以绕过应用市场的审核，所以对于紧急的bug修复以及实时性较强的功能发布（比如运营活动）比较适合。 那么，app所有功能的更新都可以使用热更新吗？</p><h3 id="_2-热更新的适用条件" tabindex="-1"><a class="header-anchor" href="#_2-热更新的适用条件" aria-hidden="true">#</a> 2.热更新的适用条件</h3><p>因为应用市场比较多，下面就重点讲下苹果app store的热更新条款。 app store禁止滥用热更新机制。 因为当开发者提交代码到app store审核通过后，开发者可能会通过热更新方式修改app 原生代码导致安全隐患，这就违反了苹果的安全隐私政策。 比如2017年2月时，苹果就发现了某种热更新方式，存在安全漏洞，如果黑客发现并利用了这个后门， 他们就能够访问到设备中的照片、麦克风和剪贴板数据以及其他涉及个人隐私的功能。 为了应用生态的安全可控，一般来说，如果涉及到更改了app 原生代码的更新，苹果都要求审核。 app的开发框架非常多，下面举个例子来讲下。 假设开发app使用的是react native框架，如果只是修改了图片资源、js代码，是可以使用热更新机制更新代码的，但是如果更改了native原生的代码，就违反了苹果的审核条款。</p><h2 id="联调" tabindex="-1"><a class="header-anchor" href="#联调" aria-hidden="true">#</a> 联调</h2><p>假设一个需求由前端和后端两名同学一起来完成。后端同学一般会给前端提供接口，接口里面会定义好入参和出参。</p><p>但是当前端开始开发页面时，接口还是不可用的，必须要等到后端同学开发好后才能调用，所以一般前端自己去「模拟」接口。</p><p>当前后端同学都开发好时，前端就可以真正去调用后端的接口了，这时需要验证接口中，URL是否正确、前端传递的参数和后端返回的数据是否正确、还有前端的一些交互逻辑是否正确。</p><p>这个验证的过程就是「联调」啦</p><h2 id="数据埋点" tabindex="-1"><a class="header-anchor" href="#数据埋点" aria-hidden="true">#</a> 数据埋点</h2><p>当用户触发一个事件，产生了一系列的用户行为数据，这时采集用户的行为数据，并上报到后台，就叫做数据埋点。</p><p>举个例子：</p><p>假设你在逛商城，你把一双鞋子加入了购物车。</p><p>这是一个加购事件，这个加购事件，产生了以下的行为数据：在商品详情页下，选择了鞋子的尺码、颜色、外观，并加入了购物车。</p><p>采集到触发的事件类型和用户行为数据，并上报到了后台，这就完成了一次数据埋点。</p><h3 id="前端埋点" tabindex="-1"><a class="header-anchor" href="#前端埋点" aria-hidden="true">#</a> 前端埋点</h3><h4 id="_1-代码埋点" tabindex="-1"><a class="header-anchor" href="#_1-代码埋点" aria-hidden="true">#</a> 1.代码埋点</h4><p>代码埋点指的是，用户通过浏览、点击等触发的事件，要通过调用sdk的方法上报事件的数据。</p><p>优点：</p><ul><li>精准的定位埋点位置</li><li>可以采集到更多自定义的数据</li></ul><p>缺点：</p><ul><li>埋点效率低，每次有新页面，都要根据需求埋点</li></ul><p>使用场景：</p><ul><li>适用于精准定位埋点位置、采集更多跟业务相关数据的复杂场景</li></ul><h4 id="_2-全埋点" tabindex="-1"><a class="header-anchor" href="#_2-全埋点" aria-hidden="true">#</a> 2.全埋点</h4><p>全埋点也叫无埋点，全埋点不是说不埋点，而是sdk自动采集所有事件并上报，然后后台通过一定的规则把想要的数据清洗出来。</p><p>优点：</p><ul><li>埋点效率高，不需要每次产品提一次需求，就找所有开发包括前端、后台、数据过一遍埋点需求</li><li>不容易出错，因为全埋点事直接上报了所有的用户行为事件，避免手工埋点失误。</li><li>有利于做自定义分析，因为数据比较全，如果用户想要知道某个按钮的点击次数，那只要搜索这个按钮唯一id，后台就可以把按钮的点击次数搜索出来了。</li></ul><p>缺点：</p><ul><li>数据量庞大，全埋点把所有的事件数据都上报，数据量比较庞大，增大了服务器、数据清洗的压力。</li></ul><p>使用场景：</p><ul><li>适用于采集更多的用户行为数据，做自定义分析，以及想提高埋点效率的场景。</li></ul><h4 id="_3-可视化埋点" tabindex="-1"><a class="header-anchor" href="#_3-可视化埋点" aria-hidden="true">#</a> 3.可视化埋点</h4><p>指的是通过一个可视化的埋点工具，运营人员圈选好需要埋点的控件和属性，sdk接收到服务器下发的埋点事件列表后，自动上报对应的埋点。</p><p>优点：</p><ul><li>提高埋点效率，运营人员可直接埋点，无需开发介入</li></ul><p>缺点：</p><ul><li>容易受界面控件位置的影响</li><li>只能上报视觉范围内的属性</li></ul><p>使用场景：</p><ul><li>适用于生命周期比较短页面的埋点，比如运营活动页面。</li></ul><h4 id="_4-小结" tabindex="-1"><a class="header-anchor" href="#_4-小结" aria-hidden="true">#</a> 4.小结</h4><p>代码埋点：用于埋业务数据复杂的场景</p><p>全埋点：用于收集更多的用户数据做自定义分析等数据挖掘场景</p><p>可视化埋点：用于运营活动页面等生命周期较短的页面场景</p><h3 id="后端埋点" tabindex="-1"><a class="header-anchor" href="#后端埋点" aria-hidden="true">#</a> 后端埋点</h3><p>对于一些需要十分准确的采集的关键事件，比如支付、登录等事件是在页面关闭之后才发送的（即点击支付、登录页面发生了跳转），有些浏览器可能会取消掉页面关闭时发出的请求，导致后端没收到上报的数据。所以这类事件建议前后端一起统计，提高数据的准确性。</p><h2 id="云服务器" tabindex="-1"><a class="header-anchor" href="#云服务器" aria-hidden="true">#</a> 云服务器</h2><p>云服务器指的是远程的计算机，也就是远程的电脑，但是它的性能比我们普通的电脑要好很多。</p><ul><li><p>云服务器的使用场景</p><ul><li><p>可以用来部署开发环境</p></li><li><p>可以部署线上后端服务、数据库</p></li><li><p>可以快速搭建云上博客</p></li><li><p>可以快速搭建门户网站</p></li><li><p>可以创建个人网盘</p></li></ul></li></ul><h2 id="跨端" tabindex="-1"><a class="header-anchor" href="#跨端" aria-hidden="true">#</a> 跨端</h2><p>这个「端」指的是终端，比如：web端、ios、安卓等，说到底就是运行我们的应用程序的平台（操作系统）。</p><p>不同的操作系统，都有提供专门的语言来编写应用程序，比如ios，提供objective-c/swift语言；安卓提供Andriod语言；web提供javascript语言。它们之间互不兼容的，比如ios语言开发的app不能在andriod系统运行。</p><p>为了降低开发成本，很多跨端解决方案就应运而生了。</p><p>跨端就是写一个应用程序，可以运行在多个终端，即一端开发多处运行。</p><p>比如：Taro框架，只要写一次，就可以运行在多个终端，包括ios、安卓、web、各种小程序。</p><h2 id="跨域" tabindex="-1"><a class="header-anchor" href="#跨域" aria-hidden="true">#</a> 跨域</h2><p>我们知道，一个URL它至少由协议、域名、接口这三部分组成的。比如：<code>https://www.a.com</code></p><h3 id="什么是跨域呢" tabindex="-1"><a class="header-anchor" href="#什么是跨域呢" aria-hidden="true">#</a> 什么是跨域呢？</h3><p>当一个请求URL的协议、域名、端口三者之间的任意一个与当前页面URL不同即为跨域。</p><p>跨域产生的原因是什么呢？</p><p>这是由于浏览器的「同源策略」限制。</p><p>什么是同源策略呢？</p><p>同源策略（Same Origin Policy）是一种约定，它是浏览器最基本的安全功能，它的出现是为了保护用户信息的安全，防止被恶意网址窃取信息。</p><p>不同源的网址会被限制以下行为：</p><ul><li>不能获取对方的Cookie、localStorage</li><li>不能给对方发送Ajax异步请求</li><li>不能获取对方的页面元素</li></ul><p>如何解决跨域？</p><p>1.反向代理</p><p>反向代理利用的是服务端向服务端发起请求不会跨域这个原理，把客户端发起的请求转发到代理服务器，然后代理服务器再把请求转发给目标服务器。</p><p>2.跨域资源共享CORS</p><p>这是一种HTTP标头机制。服务端控制好允许访问的客户端域名，当服务端收到客户端的请求时，服务端会校验当前客户端的域名是否在白名单内。如果在的话，HTTP响应头里会返回一些标记：<code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Credentials</code>等，浏览器监测到这些标记后，就会通过，不会拦截报错跨域了。</p><h2 id="协议" tabindex="-1"><a class="header-anchor" href="#协议" aria-hidden="true">#</a> 协议</h2><p>协议，就像合同一样，它会规定双方要遵循一定的规则。</p><p>我们工作中经常听到的协议指的是网络协议，它规定了客户端和服务端之间的通信规则，它规定了通信时信息必须要采用的格式和这些格式的意义，常用的协议有HTTP、HTTPS、Socket等。</p><h2 id="调试" tabindex="-1"><a class="header-anchor" href="#调试" aria-hidden="true">#</a> 调试</h2><p>当我们代码有bug时，会抛出一个异常，异常里面包含有错误信息和发生错误的代码行数。</p><p>根据报错原因和具体报错的代码行数，一步步找到问题的根源并修复的过程，就是「调试」。</p><h2 id="单元测试" tabindex="-1"><a class="header-anchor" href="#单元测试" aria-hidden="true">#</a> 单元测试</h2><p>单元测试是一种比较小型的测试。一般指的是单个函数的测试，使用不同参数的输入来校验函数输出是否符合预期。</p><p>比如：一个校验手机号码输入是否正确的函数，需要针对用户输入的各种场景写测试用例。如：手机号码为空、含有别的特殊字符、长度超过限制的测试用例。</p><p>单元测试一般是开发在编码阶段自测使用的测试方法。</p><h2 id="token" tabindex="-1"><a class="header-anchor" href="#token" aria-hidden="true">#</a> token</h2><p>token是服务端生成的一串字符，当用户第一次登录成功过后，服务端会返回一个唯一的token给到客户端，客户端，客户端以后得每一个请求都会带上这个token，用来作为用户凭证。</p><p>为什么会有token这个东西呢？</p><p>因为HTTP请求是无状态的，你的上一个请求和下一个请求，服务端没法识别是不是同一个人，所以需要一个凭证来识别用户，token因此产生。</p><p>举个例子：</p><p>小花请求登录A网站，服务端经过校验后发现小花确实是该网站的用户，服务端就会根据各种参数生成一个唯一的token，然后给客户端成功返回token后，小花登录成功。</p><p>下一秒小花请求获取商品列表数据，并带上token来请求，服务端收到请求后，把token解密后，拿到识别用户的信息，经过校验其合法性后，就知道了这个人是小花，于是给她返回了商品数据。</p><p>如果判断出token飞马，那个会直接返回未登录状态，提醒用户登录。</p><p>那token直接暴露在客户端，如果被恶意盗用伪装登录用户怎么办？</p><p>token一般都是会加密的，它会根据请求的URL、时间戳、签名等参数加密，而且在服务端拿到token后，需要密钥才能解密，所以还是比较安全的。</p><h2 id="丢包" tabindex="-1"><a class="header-anchor" href="#丢包" aria-hidden="true">#</a> 丢包</h2><p>丢包的「包」指的是，在接口请求时的请求数据包或者返回数据包。</p><p>丢包就是客户端请求的数据包，服务端没有正常收到；或者服务端返回的数据包，客户端没有收到，即数据包出现丢失。</p><p>出现丢包的原因有很多，可能是代码逻辑有bug、网络拥塞、硬件故障等等。</p><h2 id="脏数据" tabindex="-1"><a class="header-anchor" href="#脏数据" aria-hidden="true">#</a> 脏数据</h2><p>脏数据一般指的是不符合业务规范要求的数据。如果数据库中因为某些原因存入了脏数据，一般需要开发去人工处理，手动删除或者修改。</p><h2 id="网关" tabindex="-1"><a class="header-anchor" href="#网关" aria-hidden="true">#</a> 网关</h2><p>从一个房间走向另一个房间时，需要经过一扇门，而在网络空间中，从一个网络向另一个网络发送信息时，也必须经过一道关口，这就是网关。</p><p>网关有很多种类型，不同的类型起着不同的作用。</p><p>一个web服务，如果用户直接就可以访问会存在哪些问题呢？</p><p>1.安全与权限问题</p><p>如果web服务没有控制好权限，用户可能直接下载web服务的敏感资源</p><p>2.访问频次问题</p><p>比如被黑客恶意访问，同时并发大量的请求，会拖垮服务器。</p><p>所以我们需要在web服务的上一层，引入一层关卡：网关。像过安检一样，要经过审查才能进入内部服务。</p><p>当然api网关不仅仅是起到控制访问频率、鉴权等保护作用，它还有很多别的作用。</p><p>比如：外部多端统一，不同的终端，对应的网络协议可能都不一样，如果同一个功能，针对多个终端去写多分代码，比较麻烦。</p><p>如果引入API网关，就可以针对不同的终端做好协议的转换和适配。满足不同的终端对不同协议的要求，这样就不用写多份代码啦。</p><h2 id="映射" tabindex="-1"><a class="header-anchor" href="#映射" aria-hidden="true">#</a> 映射</h2><p>映射就是一种对应关系，比如每个身份证号会对应一个人名，人名可以更改，但是身份证号是不能更改的，因为已经有很多地方在使用了，更改了身份证号影响比较大。</p><p>所以映射的作用其实就是为了唯一识别某个事物。</p><h2 id="软删除" tabindex="-1"><a class="header-anchor" href="#软删除" aria-hidden="true">#</a> 软删除</h2><p>软删除也叫逻辑删除或者标记删除，它不是真的把一条记录从数据库删除，而是通过某个字段，来标记删除。</p><p>比如使用一个state的字段，state等于1表示数据是有效的，state等于0表示数据是无效的。</p><p>为什么使用软删除呢？因为很多时候，这些数据对我们来说还有价值。</p><p>那什么时候使用真正的删除（物理删除）呢？</p><p>一些没用的临时数据、或者存放了很多年已过时的数据，可以使用物理删除。</p><p>临时数据：比如临时的验证码。</p><p>存放多年的过时数据：比如某个平台。用户的操作日志。</p><p>数据存储是比较昂贵的，所以有些真的没用了的数据，建议使用物理删除。</p><h2 id="重构" tabindex="-1"><a class="header-anchor" href="#重构" aria-hidden="true">#</a> 重构</h2><p>我们工作时，经常会听到开发说，把这块功能「重构」一下，把这个项目「重构」了。</p><p>「重构」一般指的是，保持原有功能不变，重新梳理代码结构，换一种「技术栈」或者「设计模式」来实现。</p><p>「重构」一块功能，可能有以下原因：</p><p>1.技术栈老旧，落后于现有团队的技术栈，没法复用公共技术资源。</p><p>2.代码耦合度高，或者可读性、扩展性差，维护成本高</p><h2 id="敏捷开发" tabindex="-1"><a class="header-anchor" href="#敏捷开发" aria-hidden="true">#</a> 敏捷开发</h2><p>敏捷开发是现在最流行的一种软件开发方法。</p><p>敏捷开发的意思是把一个软件开发项目这个大任务拆解成多个小任务，按照一定的开发周期，增量迭代开发。</p><p>每个迭代都按照需求分析、设计、编码、测试、部署这5个步骤进行，不断地改进产品、增加新功能。</p><p>使用敏捷开发有什么好处呢？</p><p>1.快速交付</p><p>比如微信，微信里面有很多功能。如果按照传统的软件开发方式，一下子要做一个大而全的产品才能上线，那估计要等好多年。</p><p>但是使用敏捷开发方法，初期只需要语音聊天功能，后面再慢慢迭代额外的视频聊天、聊天标签动画、朋友圈等功能，开发周期按照2~6周这样，就可以快速交付了。</p><p>2.降低风险</p><p>我们上线一款产品前，还不了解这款产品是否真的适应市场，吸引用户，如果按照传统的开发方法，一下子就要做一个大而全的产品，开发周期很长，上线后发现没什么用户，想要改进，则成本非常高。</p><p>如果使用敏捷开发方法的话，就可以快速试错，当一个迭代上线时，发现不适应市场则可以不断改进，降低风险。</p><h2 id="url" tabindex="-1"><a class="header-anchor" href="#url" aria-hidden="true">#</a> URL</h2><p>URL官方含义是：统一资源定位符。一个有效的URL都指向一个唯一的资源。</p><p>这里说的资源可以是一个HTML文件、一张图片、一个视频、一个接口等等。我们平时在浏览器输入的网址就是URL，一个网页里面的请求数据的接口也是URL。</p><p>一个URL的组成部分：协议、域名、端口、资源路径、请求参数、锚点</p><h2 id="开发环境、测试环境、生产环境" tabindex="-1"><a class="header-anchor" href="#开发环境、测试环境、生产环境" aria-hidden="true">#</a> 开发环境、测试环境、生产环境</h2><h3 id="开发环境" tabindex="-1"><a class="header-anchor" href="#开发环境" aria-hidden="true">#</a> 开发环境</h3><p>「开发环境」是程序员专门用来写代码的环境，一般是自己本地的电脑，也可以是远程的云服务器。</p><p>这个阶段，程序员会根据需求单和设计稿写代码，还有前段和后端联调，联调完没问题，就把代码部署到「测试环境」啦</p><h3 id="测试环境" tabindex="-1"><a class="header-anchor" href="#测试环境" aria-hidden="true">#</a> 测试环境</h3><p>「测试环境」一般是用来给产品经理和测试同学测试功能的环境。</p><p>首先开发需要把本地写好的代码部署到测试服务器，然后准备一个测试域名，为了数据安全，这个测试域名一般是公司内网才能访问。</p><p>最后提供测试域名给产品和测试同学访问。</p><p>产品和测试验收没问题后，就把代码发布到「生产环境」啦。</p><h3 id="生产环境" tabindex="-1"><a class="header-anchor" href="#生产环境" aria-hidden="true">#</a> 生产环境</h3><p>「生产环境」是正式对外的，给客户使用的环境。</p><p>开发把测试好的代码部署到生产服务器后，准备一个生产域名，外面用户通过生产域名访问。</p><p>为了数据隔离和安全，数据库也会分为这三种环境，不同环境分别对应不同的数据库。</p><h2 id="解耦" tabindex="-1"><a class="header-anchor" href="#解耦" aria-hidden="true">#</a> 解耦</h2><p>耦合度：模块之间的依赖程度。这里的模块可以小到一个小功能，也可以大到一个系统。</p><p>解耦就是解除模块之间的耦合关系。</p><p>降低模块之间的依赖程度也可以理解为解耦，模块之间有依赖关系就必然存在耦合，0耦合是基本无可能得，那是最理想的状态。</p><p>耦合度越低，模块之间依赖的程度越低，模块的独立性、复用性和可移植性就越强。</p><p>那么如何判断2个有关联的模块的耦合程度呢？</p><p>1.是否有牵一发而动全身的现象？</p><p>一个小改动，会影响到依赖它的所有模块，这是耦合度高的典型表现。</p><p>2.看模块的复用性</p><p>可复用性越高，说明耦合度越低</p><p>3.看模块的可移植性</p><p>可移植性越高，说明耦合度越低</p><h2 id="回滚" tabindex="-1"><a class="header-anchor" href="#回滚" aria-hidden="true">#</a> 回滚</h2><p>当开发同学要上线一个新功能时，需要发布这个新功能的代码到生产环境，而且发布的代码一般都有一个版本号。</p><p>这个版本号一般是一个团队约定的格式，可以是日期格式，也可以是semver语义化版本（比如：1.0.0）等。</p><p>当然semver是最常用的。版本号的作用是啥呢？版本号既能记录当前在线上运行的代码版本，还能在突发情况下「回滚」版本。</p><p>如其名，「回滚」就是把当前线上的代码版本回退到以前的某个版本。这样的话，如果线上出现严重问题，可以快速把代码恢复到之前的安全版本。</p><h2 id="脚本" tabindex="-1"><a class="header-anchor" href="#脚本" aria-hidden="true">#</a> 脚本</h2><p>在计算机领域，脚本是一份短小的计算机程序，计算机会按照里面的指令一行一行地执行。</p><p>常见的脚本语言有：JavaScript、Python。</p><p>那么脚本语言和其他编程语言有什么不一样的么？</p><p>脚本语言是解释型语言，它不需要编译，计算机就可以直接执行。而其他语言都要先经过编译，计算机才能看懂它，才能执行。</p><p>比如我们经常说的跑个脚本，其实就是跑一份计算机可以直接执行的代码程序。</p><h2 id="封装" tabindex="-1"><a class="header-anchor" href="#封装" aria-hidden="true">#</a> 封装</h2><p>某个功能实现之后，把实现细节隐藏起来，只提供一些接口给外部调用，内部怎么实现的我们不需要关心，这就是封装。</p><h2 id="高并发" tabindex="-1"><a class="header-anchor" href="#高并发" aria-hidden="true">#</a> 高并发</h2><p>高并发指的是web系统在短时间内遇到大量网络请求的情况。</p><p>高并发会导致系统在这段时间内执行大量操作，比如对数据库的查询/存储。</p><p>高并发可能会导致请求响应过慢，甚至系统崩溃。</p><p>解决高并发的问题一般需要通过各个方面进行优化，包括增加服务节点、限制流量、降低非核心功能、算法优化、数据库优化等方式。</p><h2 id="数据库" tabindex="-1"><a class="header-anchor" href="#数据库" aria-hidden="true">#</a> 数据库</h2><p>数据库是按照一定的数据结构来组织、存储和管理数据的仓库。</p><p>那么为什么需要数据库？因为我们需要存储用户数据。当你访问一个页面，你填写表单数据提交后，如果没有把表单数据存储到服务器，页面一刷新，数据就会被刷新重置了，只有把数据存储起来，以后才能继续访问得到。</p><p>那我们平时说的mysql、oracle又是啥呢？</p><p>它们是数据库管理系统，是专门用来管理和操作数据库的大型软件。</p><h2 id="抓包" tabindex="-1"><a class="header-anchor" href="#抓包" aria-hidden="true">#</a> 抓包</h2><p>如其名，抓包就是中途拦截抓取接口请求的请求数据包和返回数据包。</p><p>抓包一般是想拿到接口的详细信息，但是要实现抓包需要安装抓包工具。</p><h2 id="私有化部署" tabindex="-1"><a class="header-anchor" href="#私有化部署" aria-hidden="true">#</a> 私有化部署</h2><p>指的是把应用部署到自己的服务器上。</p><p>私有化部署是saas产品常用的一种对外服务方式。</p><p>什么条件下可以使用私有化服务呢？</p><ul><li>有定制化的场景</li><li>数据敏感，担心数据泄露</li><li>担心第三方服务不稳定导致业务异常</li><li>企业的运维环境能满足私有化部署的条件，比如能轻松维护一个web服务、有mysql数据库、有redis服务等。</li></ul><h2 id="定时任务" tabindex="-1"><a class="header-anchor" href="#定时任务" aria-hidden="true">#</a> 定时任务</h2><p>定时任务的含义是：指定每到一个时间点，就执行一个固定任务，这个任务一般是一个计算脚本。</p><p>定时任务是后台用来定时处理数据的常用方式，并且是实时性要求不高的数据。</p><h2 id="登录态" tabindex="-1"><a class="header-anchor" href="#登录态" aria-hidden="true">#</a> 登录态</h2><p>登录态就是登录的状态，用来标识用户的唯一身份。</p><h2 id="重定向" tabindex="-1"><a class="header-anchor" href="#重定向" aria-hidden="true">#</a> 重定向</h2><p>重新跳转到另一个URL。</p><h2 id="api" tabindex="-1"><a class="header-anchor" href="#api" aria-hidden="true">#</a> API</h2><p>API就是给客户提供服务的一种方式，它还需要入参和出参。</p><p>API也可以说是接口</p><h2 id="灰度" tabindex="-1"><a class="header-anchor" href="#灰度" aria-hidden="true">#</a> 灰度</h2><p>灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。AB test就是一种灰度发布方式，让一部分用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</p><p>灰度发布的作用有以下几点：</p><p>1.降低发布带来的影响。虽然功能都在测试环境测过，但毕竟没有发布到生产环境，如果先让少部分用户先试用新版本，提前发现bug，或者性能问题，提前做好修复，就可以降低新版本带来的影响。</p><p>2.通过对新老版本的对比，观察新版本带来的效果。</p><p>灰度发布一般需要满足以下几点：</p><p>1.需要一个放量配置，给产品、运营等工作人员配置放量策略。</p><p>2.需要做到同一个用户始终访问得是同一个版本的代码，如果同个用户上个请求访问得是A版本，下个请求访问的是B版本，就可能会出问题。</p><h2 id="爬虫" tabindex="-1"><a class="header-anchor" href="#爬虫" aria-hidden="true">#</a> 爬虫</h2><h3 id="爬虫的概念和方式" tabindex="-1"><a class="header-anchor" href="#爬虫的概念和方式" aria-hidden="true">#</a> 爬虫的概念和方式</h3><p>爬虫就是使用任何技术手段，批量获取网站信息的一种方式，关键在于批量。说白了其实就是模拟真正用户去请求获取大量数据。</p><p>爬虫从网页交互维度，主要分2种方式，分别是常规爬虫和自动化爬虫。</p><p>1.常规爬虫</p><p>常规爬虫也叫裸写代码爬虫，是最原始的一种爬虫方式。比如想爬取微博热搜榜，需要经过3个步骤：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>1.确定目标地址
分析页面请求格式，找到微博实时热搜的网页地址
2.目标信息解析
请求到具体页面后，需要解析页面里面的数据，爬取回来的页面实际是一堆前端代码，通过dom api去读取代码里面的数据
3.数据存储
解析出目标信息后，可存入数据库或者写入文件中，已被后续使用。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2.自动化爬虫</p><p>自动化爬虫框架有好几款，下面介绍比较经典的puppeteer框架。</p><p>puppeteer是谷歌浏览器出的无界面（headless）chrome工具，它提供了一个高级的api来控制无头（无界面）的chrome。puppeteer可以模拟大部分用户操作，包括点击、滚动、悬浮、聚焦等大部分交互，所以只要你知道了一个网站的首页地址，就可以通过调用api去模拟用户操作来爬取整个网站的数据。</p><h3 id="爬虫的应用场景" tabindex="-1"><a class="header-anchor" href="#爬虫的应用场景" aria-hidden="true">#</a> 爬虫的应用场景</h3><p>1.抓取页面数据</p><p>2.UI自动化测试</p><p>3.生成页面截图和PDF</p><p>4.监控网页数据</p><p>5.监控网页性能</p><hr><p>https://www.xiaohongshu.com/explore/644e72120000000014024f91</p><h2 id="护城河-壁垒-门槛" tabindex="-1"><a class="header-anchor" href="#护城河-壁垒-门槛" aria-hidden="true">#</a> 护城河/壁垒/门槛</h2><p>指个人或者产品的核心竞争力，即人无我有，人有我优。</p><h2 id="千人千面" tabindex="-1"><a class="header-anchor" href="#千人千面" aria-hidden="true">#</a> 千人千面</h2><p>指依靠算法，对不同人进行不同的推荐，最早由淘宝提出</p><h2 id="权重-加权-降权" tabindex="-1"><a class="header-anchor" href="#权重-加权-降权" aria-hidden="true">#</a> 权重（加权/降权）</h2><p>指某一因素或指标相对于某一事物的重要程度，其不同于一般的比重，体现的不仅仅是某一因素或指标所占的百分比</p>`,284),d=[n];function h(s,t){return e(),p("div",null,d)}const c=a(i,[["render",h],["__file","terminology.html.vue"]]);export{c as default};
